'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNativeNode = exports.setPayloadForPin = exports.validatePayloadForPin = exports.connectionsByContainer = undefined;

var _firmata = require('firmata');

var _invariant = require('fbjs/lib/invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _HardwarePinTranslations = require('./HardwarePinTranslations');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * map firmataâ€™s Pin MODEs to what
 * type of firmata communication method
 * should be called.
 * @examples
 *   // should call digital(Read|Write)
 *   <pin mode="INPUT" />
 *
 *   // should call analog(Read|Write)
 *   <pin mode="PWM" />
 *
 *   // should call i2cConfig, is2(Read|Write)
 *   <pin mode="i2c" />
 */
var FIRMATA_COMMUNICATION_METHOD = {
  '0': 'digital', // input
  '1': 'digital', // output
  '2': 'analog', // analog
  '3': 'analog', // pwm
  '4': 'servo', // servo
  '5': 'UNKNOWN', // shift
  '6': 'i2c', // i2c
  '7': 'UNKNOWN', // onewire
  '8': 'UNKNOWN', // stepper
  '16': 'UNKNOWN', // unknown
  '127': 'IGNORE' }; // ignore


var deferredReader = function deferredReader(connection, pin) {
  return function (value) {
    return connection.readers[pin].call(value);
  };
};

var setReader = function setReader(connection, communicationType, payload) {
  if (!connection.readers[payload.pin]) {
    var reader = deferredReader(connection, payload.pin);
    connection.readers[payload.pin] = { reader: reader, call: null };

    // map A0-A5 to the appropriate analog index for node-firmata
    var toNodeFirmataMapping = typeof payload.pin === 'string' ? parseInt(payload.pin.slice(1), 10) : payload.pin;
    connection.board[communicationType + 'Read'](toNodeFirmataMapping, reader);
    connection.readers[payload.pin].call = payload.onRead;
  }

  connection.readers[payload.pin].call = payload.onRead;
};

var connectionsByContainer = exports.connectionsByContainer = {};

// matches return value of the input value

var findConnectionForRootId = function findConnectionForRootId(rootID) {
  for (var connection in connectionsByContainer) {
    if (connectionsByContainer[connection].rootID !== rootID) {
      continue;
    }

    return connectionsByContainer[connection];
  }
};

/**
 * Validates a desired payload to a Pin according the boards reported Pin
 * configuration.
 */
var validatePayloadForPin = exports.validatePayloadForPin = function validatePayloadForPin(maybeConnection, payload) {
  if (payload == null) {
    return;
  }

  var connection = typeof maybeConnection === 'string' ? findConnectionForRootId(maybeConnection) : maybeConnection;

  (0, _invariant2.default)(!!connection, 'Attempting to update connection string "%s" that no longer exists', connection);

  var board = connection.board;
  var pins = board.pins;
  var MODES = board.MODES;


  var mode = MODES[payload.mode];

  // map from mode identifier back to a friendly string
  var idToModeName = {};
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(MODES)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _mode = _step.value;

      idToModeName[MODES[_mode]] = _mode;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var normalizedPin = (0, _HardwarePinTranslations.analogToDigital)(payload.pin);
  var _pins$normalizedPin = pins[normalizedPin];
  var supportedModes = _pins$normalizedPin.supportedModes;
  var analogChannel = _pins$normalizedPin.analogChannel;

  (0, _invariant2.default)(supportedModes.indexOf(mode) !== -1 || analogChannel === 127 && payload.mode === 'DIGITAL', 'Unsupported mode "%s" for pin "%s".\nSupported modes are: "%s"', payload.mode, payload.pin, supportedModes.map(function (m) {
    return idToModeName[m];
  }).join('", "') || 'DIGITAL');
};

/**
 * Sets a pin's values to the desired payload.
 */
var setPayloadForPin = exports.setPayloadForPin = function setPayloadForPin(maybeConnection, payload) {
  if (payload == null) {
    return;
  }

  var connection = typeof maybeConnection === 'string' ? findConnectionForRootId(maybeConnection) : maybeConnection;

  if (!connection) {
    return;
  }

  var board = connection.board;
  var MODES = board.MODES;

  // console.log(`set pinMode of "%s" to "%s"`, payload.pin, payload.mode);

  var normalizedPin = (0, _HardwarePinTranslations.analogToDigital)(payload.pin);
  board.pinMode(normalizedPin, MODES[payload.mode]);
  var communicationType = FIRMATA_COMMUNICATION_METHOD[MODES[payload.mode]];
  if (typeof payload.value !== 'undefined') {
    // console.log(`${communicationType}Write to "%s" with "%s"`, payload.pin, payload.value);
    board[communicationType + 'Write'](payload.pin, +payload.value);
  }

  if (payload.onRead) {
    setReader(connection, communicationType, payload);
  }
};

/**
 * NOTE: This is a leaky abstraction. It returns the direct Board IO instance.
 */
var getNativeNode = exports.getNativeNode = function getNativeNode(component) {
  var connection = findConnectionForRootId(component._rootNodeID);

  if (connection) {
    return connection.board;
  }
};