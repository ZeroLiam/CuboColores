/* eslint-disable */

'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

describe('ReactHardware Integration', function () {
  var React = require('react');
  var ReactHardware = require('../index')['default'];
  var ReactHardwareMount = require('../ReactHardwareMount')['default'];

  var Board = void 0;
  var Pin = void 0;
  var Container = void 0;

  beforeEach(function () {
    Board = ReactHardware.Board;
    Container = ReactHardware.Container;
    Pin = ReactHardware.Pin;
  });

  afterEach(function () {
    ReactHardwareMount._emptyCache();
  });

  it('should handle a simple flow with reusing the root node', function (done) {
    var container = '/dev/cu.usbmodem1451';
    ReactHardware.render(React.createElement('pin', { pin: 13, value: 0, mode: 'INPUT' }), container, function (inst) {
      expect(inst).toBeDefined();
      var props = inst._currentElement.props;

      expect(props.pin).toBe(13);
      expect(props.value).toBe(0);
      expect(props.mode).toBe('INPUT');

      diffs();
    });

    function diffs() {
      ReactHardware.render(React.createElement('pin', { pin: 13, value: 1, mode: 'INPUT' }), container, function (inst) {
        // TODO: verify child pin attributes
        expect(inst).toBeDefined();
        var props = inst._currentElement.props;

        expect(props.pin).toBe(13);
        expect(props.value).toBe(1);
        expect(props.mode).toBe('INPUT');

        ReactHardware.unmountComponentAtNode(container);
        done();
      });
    }
  });

  it('should render multiple children', function (done) {
    var container = '/dev/cu.usbmodem1451';

    var TestApplication = function (_React$Component) {
      _inherits(TestApplication, _React$Component);

      function TestApplication() {
        _classCallCheck(this, TestApplication);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(TestApplication).apply(this, arguments));
      }

      _createClass(TestApplication, [{
        key: 'render',
        value: function render() {
          return React.createElement(
            Container,
            null,
            React.createElement('pin', { pin: 10, value: 0, mode: 'OUTPUT' }),
            React.createElement('pin', { pin: 11, value: 0, mode: 'OUTPUT' }),
            React.createElement('pin', { pin: 12, value: 0, mode: 'OUTPUT' }),
            React.createElement('pin', { pin: 13, value: 0, mode: 'OUTPUT' })
          );
        }
      }]);

      return TestApplication;
    }(React.Component);

    ReactHardware.render(React.createElement(TestApplication, null), container, function (inst) {
      var internalComponent = inst._reactInternalInstance._renderedComponent;
      var container = internalComponent._currentElement;
      var children = container.props.children;

      expect(children.length).toBe(4);
      done();
    });
  });

  it('should support changing a child', function (done) {
    var container = '/dev/cu.usbmodem1451';

    var OtherPin = function (_React$Component2) {
      _inherits(OtherPin, _React$Component2);

      function OtherPin() {
        _classCallCheck(this, OtherPin);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(OtherPin).apply(this, arguments));
      }

      _createClass(OtherPin, [{
        key: 'render',
        value: function render() {
          return React.createElement('pin', { pin: 10, value: 1, mode: 'OUTPUT' });
        }
      }]);

      return OtherPin;
    }(React.Component);

    var TestApplication = function (_React$Component3) {
      _inherits(TestApplication, _React$Component3);

      function TestApplication() {
        _classCallCheck(this, TestApplication);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(TestApplication).call(this));

        _this3.state = { swapped: false };
        return _this3;
      }

      _createClass(TestApplication, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
          var _this4 = this;

          setTimeout(function (_) {
            return _this4.setState({ swapped: true });
          }, 10);
        }
      }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
          done();
        }
      }, {
        key: 'render',
        value: function render() {
          if (this.state.swapped) {
            return React.createElement(OtherPin, { ref: 'other' });
          }

          return React.createElement('pin', { pin: 10, value: 0, mode: 'OUTPUT' });
        }
      }]);

      return TestApplication;
    }(React.Component);

    ReactHardware.render(React.createElement(TestApplication, null), container);
  });
});