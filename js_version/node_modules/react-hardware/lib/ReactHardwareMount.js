'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                   * React Hardware mount method.
                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                   * 
                                                                                                                                                                                                                                                   */

var _ReactInstanceHandles = require('react/lib/ReactInstanceHandles');

var _ReactInstanceHandles2 = _interopRequireDefault(_ReactInstanceHandles);

var _ReactElement = require('react/lib/ReactElement');

var _ReactElement2 = _interopRequireDefault(_ReactElement);

var _ReactUpdates = require('react/lib/ReactUpdates');

var _ReactUpdates2 = _interopRequireDefault(_ReactUpdates);

var _ReactUpdateQueue = require('react/lib/ReactUpdateQueue');

var _ReactUpdateQueue2 = _interopRequireDefault(_ReactUpdateQueue);

var _ReactReconciler = require('react/lib/ReactReconciler');

var _ReactReconciler2 = _interopRequireDefault(_ReactReconciler);

var _shouldUpdateReactComponent = require('react/lib/shouldUpdateReactComponent');

var _shouldUpdateReactComponent2 = _interopRequireDefault(_shouldUpdateReactComponent);

var _instantiateReactComponent = require('react/lib/instantiateReactComponent');

var _instantiateReactComponent2 = _interopRequireDefault(_instantiateReactComponent);

var _invariant = require('fbjs/lib/invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _warning = require('fbjs/lib/warning');

var _warning2 = _interopRequireDefault(_warning);

var _firmata = require('firmata');

var _ReactHardwareDefaultInjection = require('./ReactHardwareDefaultInjection');

var _ReactHardwareDefaultInjection2 = _interopRequireDefault(_ReactHardwareDefaultInjection);

var _HardwareManager = require('./HardwareManager');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TRANSIENT_CONTAINER_IDENTIFIER = '__AutomaticallyDiscoveredPort';

_ReactHardwareDefaultInjection2.default.inject();

var ReactHardwareMount = {
  // for react devtools
  _instancesByReactRootID: {},
  nativeTagToRootNodeID: function nativeTagToRootNodeID(nativeTag) {
    throw new Error('TODO: implement nativeTagToRootNodeID ' + nativeTag);
  },


  /**
   * Renders a React component to the supplied `container` port.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the pins as necessary to reflect
   * the latest React component.
   */
  render: function render(nextElement) {
    var container = arguments.length <= 1 || arguments[1] === undefined ? TRANSIENT_CONTAINER_IDENTIFIER : arguments[1];
    var callback = arguments[2];

    // WIP: it appears as though nextElement.props is an empty object...
    (0, _invariant2.default)(_ReactElement2.default.isValidElement(nextElement), 'ReactHardware.render(): Invalid component element.%s', typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
    // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '');

    (0, _warning2.default)(typeof container === 'string' ? container === TRANSIENT_CONTAINER_IDENTIFIER || _firmata.Board.isAcceptablePort({ comName: container }) : true, 'Attempting to render into a possibly invalid port: %s', container);

    if (container) {
      var prevConnection = _HardwareManager.connectionsByContainer[container];

      if (prevConnection) {
        (0, _warning2.default)(prevConnection.status !== 'CONNECTING', 'Attempting to render to port `%s` that is in the process of mounting. ' + 'You should wait until ReactHardware(comp, port, callback) callback is ' + 'called to render again', container);

        if (prevConnection.status === 'CONNECTED') {
          var prevComponent = prevConnection.component;
          if (prevComponent) {
            // $FlowFixMe
            var prevWrappedElement = prevComponent._currentElement;
            var prevElement = prevWrappedElement.props;
            if ((0, _shouldUpdateReactComponent2.default)(prevElement, nextElement)) {
              var _ret = function () {
                // $FlowFixMe
                var publicInst = prevComponent._renderedComponent.getPublicInstance();
                var updatedCallback = callback && function () {
                  // appease flow
                  if (callback) {
                    callback.call(publicInst);
                  }
                };

                ReactHardwareMount._updateRootComponent(prevComponent, nextElement, container, updatedCallback);
                return {
                  v: publicInst
                };
              }();

              if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
            } else {
              (0, _warning2.default)(true, 'Unexpected `else` branch in ReactHardware.render()');
            }
          }
        }
      }
    }

    // const id = 'TODO: generate IDs';
    var id = _ReactInstanceHandles2.default.createReactRootID(container || 0);
    _HardwareManager.connectionsByContainer[container] = {
      rootID: id,
      status: 'CONNECTING',
      component: null,
      board: null,
      readers: {}
    };

    var nextComponent = (0, _instantiateReactComponent2.default)(nextElement);
    connect(container, function (board, resolvedPort) {
      ReactHardwareMount.renderComponent(id, resolvedPort, nextComponent, nextElement, board, callback);
    });

    // needed for react-devtools
    ReactHardwareMount._instancesByReactRootID[id] = nextComponent;

    return nextComponent.getPublicInstance();
  },


  /**
   * Unmounts a component.
   */
  unmountComponentAtNode: function unmountComponentAtNode(container) {
    var component = _HardwareManager.connectionsByContainer[container].component;

    if (!component) {
      return false;
    }
    // $FlowFixMe
    var instance = component.getPublicInstance();

    _ReactReconciler2.default.unmountComponent(instance);
    delete _HardwareManager.connectionsByContainer.component;
    // TODO: does Firmata support disconnect/cleanup events?
    return true;
  },


  /**
   * Take a component thatâ€™s already mounted and replace its props
   */
  _updateRootComponent: function _updateRootComponent(prevComponent, // component instance already in the DOM
  nextElement, // component instance to render
  container, // firmata connection port
  callback // function triggered on completion
  ) {
    _ReactUpdateQueue2.default.enqueueElementInternal(prevComponent, nextElement);
    if (callback) {
      _ReactUpdateQueue2.default.enqueueCallbackInternal(prevComponent, callback);
    }

    return prevComponent;
  },
  renderComponent: function renderComponent(rootID, container, nextComponent, nextElement, board, // Firmata instnace
  callback) {
    // FIXME: this should only be hit in testing when we
    // clear the connectionsByContainer cache. Totally a hack.
    if (!_HardwareManager.connectionsByContainer[container]) {
      return nextComponent ? nextComponent.getPublicInstance() : null;
    }

    var component = nextComponent || (0, _instantiateReactComponent2.default)(nextElement);

    _HardwareManager.connectionsByContainer[container].status = 'CONNECTED';
    _HardwareManager.connectionsByContainer[container].component = component;
    _HardwareManager.connectionsByContainer[container].board = board;
    _HardwareManager.connectionsByContainer[container].rootID = rootID;

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.
    _ReactUpdates2.default.batchedUpdates(function () {
      // Batched mount component
      var transaction = _ReactUpdates2.default.ReactReconcileTransaction.getPooled();
      transaction.perform(function () {
        component.mountComponent(transaction, rootID, { _idCounter: 0 }, {});
        if (callback) {
          var publicInst = component.getPublicInstance();
          callback(publicInst);
        }
      });
      _ReactUpdates2.default.ReactReconcileTransaction.release(transaction);
    });

    return component.getPublicInstance();
  },
  getNode: function getNode(nativeTag) {
    return nativeTag;
  },


  // needed for react devtools
  getID: function getID(nativeTag) {
    var id = _ReactInstanceHandles2.default.getReactRootIDFromNodeID(nativeTag);
    console.warn('TODO: ReactHardwareMount.getID(%s) ->  %s', nativeTag, id);
    return id;
  },


  /**
   * Empty connections by container. Used by test utils to get
   * a clean slate. Totally a bad hack.
   */
  _emptyCache: function _emptyCache() {
    Object.keys(_HardwareManager.connectionsByContainer).forEach(function (connection) {
      // TODO: actually disconnect
      delete _HardwareManager.connectionsByContainer[connection];
    });
  }
};

/**
  * Get or create a connection to a given port
  */
function connect(maybePort, callback) {
  if (maybePort !== TRANSIENT_CONTAINER_IDENTIFIER) {
    connect(maybePort);
  } else {
    console.info('Requesting port...');
    _firmata.Board.requestPort(function (err, port) {
      if (err) {
        throw err;
      } else {
        console.log(port.comName);
        // Remap the connection from transient state to the real port
        _HardwareManager.connectionsByContainer[port.comName] = _HardwareManager.connectionsByContainer[maybePort];
        delete _HardwareManager.connectionsByContainer[maybePort];
        connect(port.comName);
      }
    });
  }

  function connect(port) {
    console.info('Connecting to port "%s"', port);
    var board = new _firmata.Board(port, function (err) {
      if (err) {
        console.error('Failed connecting to port %s', port);
        throw err;
      }

      callback(board, port);
    });
  }
}

exports.default = ReactHardwareMount;